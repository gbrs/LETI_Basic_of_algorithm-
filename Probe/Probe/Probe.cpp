/*
		 int 4
   short int 2
	long int 4
	   float 4
	  double 8
 long double 8
		char 1
		bool 1
*/

// печать занимаемых байтов для разных типов данных

#include <iostream>
#include <iomanip>;

using namespace std;

int main()
{
	// память выделенная под разные типы данных
	cout << setw(12) << "int" << " " << sizeof(int) << endl;
	cout << setw(12) << "short int" << " " << sizeof(short int) << endl;
	cout << setw(12) << setw(12)<< "long int" << " " << sizeof(long int) << endl;
	cout << setw(12) << "float" << " " << sizeof(float) << endl;
	cout << setw(12) << "double" << " " << sizeof(double) << endl;
	cout << setw(12) << "long double" << " " << sizeof(long double) << endl;
	cout << setw(12) << "char" << " " << sizeof(char) << endl;
	cout << setw(12) << "bool" << " " << sizeof(bool) << endl;

	// создание маски в 4 байта
	unsigned int bytes_amount = 4;  // Количество байт
	unsigned int order = bytes_amount * 8; // Количество разрядов
	unsigned int mask = 1 << (order - 1); // Маска побитового сравнения смещением единственной единицы влево на (order - 1)

	int value = 61901;
	// выводим побитово число int
	cout << setw(12) << "int" << " ";
	for (int i = 1; i <= order; i++)
	{
		cout << ((value & mask) ? '1' : '0');  // если сейчас на первой позиции 0, то value & mask = 0 => false
		value <<= 1; // Побитовый сдвиг числа
		if (i == 1)  // отделяем знак
		{
			cout << ' ';
		}
	}
	cout << endl;

	// благодаря union к одним ячейкам памяти сможем обращаться как если бы там лежали либо float, либо int.
	// Положим мы float, но обрабатывать будем как int, чтобы использовать побитовый сдвиг
	union
	{
		int value;
		float number;
	} Float;
	
	Float.number = -9.625;
	
	cout << setw(12) << "float" << " ";
	for (int i = 1; i <= order; i++)
	{
		cout << ((Float.value & mask) ? '1' : '0');
		Float.value <<= 1;
		// 1) отделяем знак "мантиссы"
		// у вещественных в отличие от целых, чтобы получить число, обратное по сложению, достаточно инвертировать один бит знака			 
		// 2) отделяем экспоненту. От записанного значения надо отнять 127 (семь 1). Диапазон от -127 до 128
		if (i == 9 || i == 1)
		{
			cout << ' ';
		}
	}
	cout << endl;

	/*
	// теперь то же с double, занимающим не 4, а 8 байт
	// Расположим здесь не один int, но массив из двух intов
	union
	{
		int value[2];
		double number;
	} Double;

	Double.number = -9.625;

	cout << "double" << " ";
	for (int i = 1; i <= order; i++)
	{
		cout << ((Double.value[1] & mask) ? '1' : '0');
		// на самом же деле биты записаны в память начиная с младшего (а мы выводим как нам удобно),
		// поэтому сначала выводим второй из intов, а не первый.
		Double.value[1] <<= 1;
		if (i == 12 || i == 1)
		{
			cout << ' ';
		}
	}
	for (int i = 1; i <= order; i++)
	{
		cout << ((Double.value[0] & mask) ? '1' : '0');
		Double.value[0] <<= 1;
	}
	*/

	// теперь то же с double, занимающим не 4, а 8 байт
	// Расположим здесь не int, а long long
	
	// создание маски в 8 байт
	order *= 2;
	// конкретно целое числовое значение в long long кладут с "постфиксом" LL.
	// Маска побитового сравнения смещением единственной единицы влево на (order - 1)
	unsigned long long mask8 = 1LL << (order - 1);

	// благодаря union к одним ячейкам памяти сможем обращаться как если бы там лежали либо double, либо long long.
	// Положим мы double, но обрабатывать будем как long long, чтобы использовать побитовый сдвиг
	union
	{
		long long value;
		double number;
	} Double;

	Double.number = -9.625;

	
	cout << setw(12) << "double" << " ";
	for (int i = 1; i <= order; i++)
	{
		cout << ((Double.value & mask8) ? '1' : '0');
		Double.value <<= 1;
		// 1) отделяем знак "мантиссы"
		// у вещественных в отличие от целых, чтобы получить число, обратное по сложению, достаточно инвертировать один бит знака			 
		// 2) отделяем экспоненту. От записанного значения надо отнять 1023 (десять 1). Диапазон от -1023 - 1024
		if (i == 12 || i == 1)
		{
			cout << ' ';
		}
	}
	cout << endl;
	
}

/*
Мои измышления - не нашел точного описания.
float 9.5 записывается так: 0 10000010 00110000000000000000000
Экспонента: 130 - 127 = 3. Т.е. наш базис - 8.
В мантиссе записывается уже только "остаток", оставшийся после подбора наибольшего возможного базиса: 9.5 - 8 = 1.5
Чтобы получить дополнительную 1: надо 8 поделить на 2 3 раза, а чтобы 0.5 - 4 раза.
Поэтому в мантиссе на 3-ей и 4-ой позиции будут единицы.
-9.5 отличается от 9.5 только первым битом: 1 вместо 0
*/